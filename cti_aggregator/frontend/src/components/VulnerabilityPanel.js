// src/components/VulnerabilityPanel.js
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Input,
  Text,
  Heading,
  Flex,
  Spinner,
  Alert,
  Badge,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Button,
  ButtonGroup,
  FormControl,
  FormLabel,
  Stack,
  HStack,
  Popover,
  PopoverTrigger,
  PopoverContent,
  PopoverBody,
  useColorModeValue,
  InputGroup,
  InputRightElement
} from '@chakra-ui/react';
import DatePicker from 'react-datepicker';
import "react-datepicker/dist/react-datepicker.css";
import { CalendarIcon } from '@chakra-ui/icons';

const VulnerabilityPanel = ({ dataSource }) => {
  const [vulnerabilities, setVulnerabilities] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [error, setError] = useState(null);
  const [selectedVuln, setSelectedVuln] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 10;
  
  // Date filter states
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);
  const [isDateFilterActive, setIsDateFilterActive] = useState(false);
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const [selectingField, setSelectingField] = useState(null); // 'start' or 'end'
  const datePickerRef = useRef(null);

  // Use color mode values
  const tableBg = useColorModeValue('white', 'gray.800');
  const headerBg = useColorModeValue('gray.100', 'gray.700');
  const borderColor = useColorModeValue('gray.200', 'gray.600');
  const hoverBg = useColorModeValue('blue.50', 'blue.900');
  const selectedBg = useColorModeValue('blue.100', 'blue.800');
  const descriptionBg = useColorModeValue('gray.50', 'gray.900');
  const btnColor = useColorModeValue('blue.500', 'blue.300');
  const formBg = useColorModeValue('gray.50', 'gray.700');
  const calendarBg = useColorModeValue('white', 'gray.700');

  useEffect(() => {
    const fetchVulnerabilities = async () => {
      try {
        setLoading(true);
        console.log('Fetching vulnerabilities from API...');
        const response = await fetch('http://localhost:8000/api/vulnerabilities/');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Vulnerabilities fetched successfully:', data);
        setVulnerabilities(data);
        setLoading(false);
      } catch (error) {
        console.error("Error fetching vulnerability data:", error);
        setError(`Failed to load vulnerability data: ${error.message}`);
        setLoading(false);
      }
    };

    fetchVulnerabilities();
  }, [dataSource]);

  // Apply both text search and date filters
  const filteredVulnerabilities = vulnerabilities.filter(vuln => {
    // Apply text search filter
    const matchesSearch = 
      vuln.cve_id?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (vuln.vulnerability_name && vuln.vulnerability_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
      (vuln.description && vuln.description.toLowerCase().includes(searchTerm.toLowerCase()));
    
    // Apply date filter if active
    let matchesDateFilter = true;
    if (isDateFilterActive && startDate && endDate) {
      const vulnDate = vuln.published_date ? new Date(vuln.published_date) : null;
      if (vulnDate) {
        // Reset hours to compare dates only
        const vulnDateOnly = new Date(vulnDate.setHours(0, 0, 0, 0));
        const startDateOnly = new Date(startDate.setHours(0, 0, 0, 0));
        const endDateOnly = new Date(endDate.setHours(0, 0, 0, 0));
        
        matchesDateFilter = vulnDateOnly >= startDateOnly && vulnDateOnly <= endDateOnly;
      } else {
        matchesDateFilter = false; // No date to compare
      }
    }
    
    return matchesSearch && matchesDateFilter;
  });

  // Calculate pagination
  const totalPages = Math.ceil(filteredVulnerabilities.length / itemsPerPage);
  
  // Get current page items
  const indexOfLastItem = currentPage * itemsPerPage;
  const indexOfFirstItem = indexOfLastItem - itemsPerPage;
  const currentItems = filteredVulnerabilities.slice(indexOfFirstItem, indexOfLastItem);

  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
    setCurrentPage(1); // Reset to first page when searching
  };

  const handleRowClick = (vuln) => {
    setSelectedVuln(vuln);
  };

  const handlePageChange = (page) => {
    setCurrentPage(page);
  };

  const handleDateSelect = (date) => {
    if (selectingField === 'start') {
      // If selecting start date and there's already an end date before it,
      // reset the end date
      if (endDate && date > endDate) {
        setEndDate(null);
      }
      setStartDate(date);
      // Automatically switch to selecting end date
      setSelectingField('end');
    } else if (selectingField === 'end') {
      // If selecting end date and it's before the start date,
      // update start date to be the day before
      if (startDate && date < startDate) {
        setStartDate(null);
        setStartDate(date);
        setSelectingField('end'); // Keep selecting end date
      } else {
        setEndDate(date);
        // Both dates are now selected, close the calendar
        if (startDate) {
          setIsCalendarOpen(false);
        }
      }
    }
  };

  const openCalendar = (field) => {
    setSelectingField(field);
    setIsCalendarOpen(true);
  };

  const handleClickOutside = (e) => {
    if (datePickerRef.current && !datePickerRef.current.contains(e.target)) {
      setIsCalendarOpen(false);
    }
  };

  useEffect(() => {
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const applyDateFilter = () => {
    if (startDate && endDate) {
      setIsDateFilterActive(true);
      setCurrentPage(1); // Reset to first page when applying filter
    }
  };

  const clearDateFilter = () => {
    setStartDate(null);
    setEndDate(null);
    setIsDateFilterActive(false);
    setCurrentPage(1); // Reset to first page when clearing filter
  };

  const getSeverityColor = (severity) => {
    const severityLower = (severity || '').toLowerCase();
    switch (severityLower) {
      case 'critical':
        return 'red';
      case 'high':
        return 'orange';
      case 'medium':
        return 'yellow';
      case 'low':
        return 'green';
      default:
        return 'gray';
    }
  };

  // Calculate the monthsShown based on screen size
  const getMonthsToShow = () => {
    return 2; // Show 2 months, past month and current month
  };

  const formatDate = (date) => {
    if (!date) return 'Select date';
    return date.toLocaleDateString();
  };

  if (loading) return (
    <Flex justify="center" align="center" h="100%">
      <Spinner size="xl" color="blue.500" thickness="4px" />
    </Flex>
  );
  
  if (error) return (
    <Alert status="error" borderRadius="md">
      {error}
    </Alert>
  );

  return (
    <Box h="100%" display="flex" flexDirection="column">
      <Stack direction={{ base: 'column', md: 'row' }} spacing={4} mb={3}>
        <Box flex="1">
          <Input
            placeholder="Search vulnerabilities by CVE ID, name, or description..."
            value={searchTerm}
            onChange={handleSearchChange}
            size="sm"
          />
        </Box>
        
        <Box p={2} bg={formBg} borderRadius="md" borderWidth="1px" borderColor={borderColor}>
          <Stack direction={{ base: 'column', md: 'row' }} spacing={3} align="flex-end">
            <FormControl>
              <FormLabel fontSize="xs">Date Range</FormLabel>
              <Stack direction="row" spacing={1}>
                <Popover
                  isOpen={isCalendarOpen && selectingField === 'start'}
                  onClose={() => setIsCalendarOpen(false)}
                  closeOnBlur={false}
                  placement="bottom-start"
                  gutter={4}
                >
                  <PopoverTrigger>
                    <InputGroup size="sm" width={{ base: '100%', md: '150px' }}>
                      <Input
                        placeholder="Start Date"
                        value={startDate ? formatDate(startDate) : ''}
                        readOnly
                        onClick={() => openCalendar('start')}
                        cursor="pointer"
                        bg={selectingField === 'start' ? 'blue.50' : 'white'}
                        borderColor={selectingField === 'start' ? 'blue.500' : borderColor}
                      />
                      <InputRightElement>
                        <CalendarIcon color="gray.500" />
                      </InputRightElement>
                    </InputGroup>
                  </PopoverTrigger>
                  {isCalendarOpen && selectingField === 'start' && (
                    <PopoverContent width="auto" ref={datePickerRef}>
                      <PopoverBody p={2}>
                        <Box 
                          className="custom-datepicker-wrapper" 
                          bg={calendarBg}
                          p={2}
                          borderRadius="md"
                        >
                          <DatePicker
                            selected={startDate}
                            onChange={handleDateSelect}
                            monthsShown={getMonthsToShow()}
                            inline
                            highlightDates={[startDate, endDate].filter(Boolean)}
                            selectsStart
                            startDate={startDate}
                            endDate={endDate}
                          />
                        </Box>
                      </PopoverBody>
                    </PopoverContent>
                  )}
                </Popover>

                <Text alignSelf="center" fontSize="sm">to</Text>

                <Popover
                  isOpen={isCalendarOpen && selectingField === 'end'}
                  onClose={() => setIsCalendarOpen(false)}
                  closeOnBlur={false}
                  placement="bottom-start"
                  gutter={4}
                >
                  <PopoverTrigger>
                    <InputGroup size="sm" width={{ base: '100%', md: '150px' }}>
                      <Input
                        placeholder="End Date"
                        value={endDate ? formatDate(endDate) : ''}
                        readOnly
                        onClick={() => openCalendar('end')}
                        cursor="pointer"
                        bg={selectingField === 'end' ? 'blue.50' : 'white'}
                        borderColor={selectingField === 'end' ? 'blue.500' : borderColor}
                      />
                      <InputRightElement>
                        <CalendarIcon color="gray.500" />
                      </InputRightElement>
                    </InputGroup>
                  </PopoverTrigger>
                  {isCalendarOpen && selectingField === 'end' && (
                    <PopoverContent width="auto" ref={datePickerRef}>
                      <PopoverBody p={2}>
                        <Box 
                          className="custom-datepicker-wrapper" 
                          bg={calendarBg}
                          p={2}
                          borderRadius="md"
                        >
                          <DatePicker
                            selected={endDate}
                            onChange={handleDateSelect}
                            monthsShown={getMonthsToShow()}
                            inline
                            highlightDates={[startDate, endDate].filter(Boolean)}
                            selectsEnd
                            startDate={startDate}
                            endDate={endDate}
                            minDate={startDate}
                          />
                        </Box>
                      </PopoverBody>
                    </PopoverContent>
                  )}
                </Popover>
              </Stack>
            </FormControl>
            
            <ButtonGroup size="sm">
              <Button 
                colorScheme="blue" 
                onClick={applyDateFilter}
                isDisabled={!startDate || !endDate}
              >
                Apply Filter
              </Button>
              {isDateFilterActive && (
                <Button 
                  variant="outline"
                  onClick={clearDateFilter}
                >
                  Clear
                </Button>
              )}
            </ButtonGroup>
          </Stack>
        </Box>
      </Stack>
      
      {isDateFilterActive && (
        <Box mb={3} p={2} bg="blue.50" borderRadius="md" borderWidth="1px" borderColor="blue.200">
          <Text fontSize="sm" color="blue.600">
            <strong>Date Filter Active:</strong> Showing vulnerabilities from {startDate.toLocaleDateString()} to {endDate.toLocaleDateString()}
          </Text>
        </Box>
      )}
      
      <Box 
        flex="1" 
        borderWidth="1px" 
        borderColor={borderColor} 
        borderRadius="md" 
        overflow="hidden"
        mb={3}
      >
        <Box overflowY="auto" maxH="600px" bg={tableBg}>
          <Table size="sm" variant="simple">
            <Thead position="sticky" top={0} zIndex={1} bg={headerBg}>
              <Tr>
                <Th width="15%">CVE-ID</Th>
                <Th width="40%">Name</Th>
                <Th width="15%">Severity</Th>
                <Th width="15%">Published Date</Th>
              </Tr>
            </Thead>
            <Tbody>
              {currentItems.length > 0 ? (
                currentItems.map((vuln) => (
                  <Tr 
                    key={vuln.cve_id || vuln.id} 
                    onClick={() => handleRowClick(vuln)}
                    bg={selectedVuln && selectedVuln.cve_id === vuln.cve_id ? selectedBg : 'inherit'}
                    _hover={{ bg: hoverBg, cursor: 'pointer' }}
                    transition="background-color 0.2s"
                  >
                    <Td>{vuln.cve_id || 'N/A'}</Td>
                    <Td isTruncated maxW="40vw">{vuln.vulnerability_name || 'N/A'}</Td>
                    <Td>
                      <Badge colorScheme={getSeverityColor(vuln.severity)}>
                        {vuln.severity || 'Unknown'}
                      </Badge>
                    </Td>
                    <Td>{vuln.published_date ? new Date(vuln.published_date).toLocaleDateString() : 'N/A'}</Td>
                  </Tr>
                ))
              ) : (
                <Tr>
                  <Td colSpan={4} textAlign="center" py={4}>
                    <Text color="gray.500">No vulnerabilities found.</Text>
                  </Td>
                </Tr>
              )}
            </Tbody>
          </Table>
        </Box>

        {/* Pagination Controls */}
        {totalPages > 1 && (
          <Flex justify="center" align="center" p={2} bg={headerBg}>
            <ButtonGroup size="xs" isAttached variant="outline">
              <Button
                onClick={() => handlePageChange(1)}
                isDisabled={currentPage === 1}
                colorScheme="blue"
              >
                First
              </Button>
              <Button
                onClick={() => handlePageChange(currentPage - 1)}
                isDisabled={currentPage === 1}
                colorScheme="blue"
              >
                Prev
              </Button>
              <Button colorScheme="blue" variant="solid">
                {currentPage} of {totalPages}
              </Button>
              <Button
                onClick={() => handlePageChange(currentPage + 1)}
                isDisabled={currentPage === totalPages}
                colorScheme="blue"
              >
                Next
              </Button>
              <Button
                onClick={() => handlePageChange(totalPages)}
                isDisabled={currentPage === totalPages}
                colorScheme="blue"
              >
                Last
              </Button>
            </ButtonGroup>
          </Flex>
        )}
      </Box>
      
      <Box 
        p={3} 
        bg={descriptionBg} 
        borderRadius="md"
        height="150px"
      >
        <Heading size="xs" mb={1}>Description</Heading>
        <Box 
          overflowY="auto" 
          p={2} 
          bg={tableBg} 
          borderRadius="sm" 
          borderWidth="1px"
          borderColor={borderColor}
          height="calc(100% - 24px)"
        >
          {selectedVuln ? (
            <Text fontSize="sm">{selectedVuln.description || 'No description available.'}</Text>
          ) : searchTerm && filteredVulnerabilities.length > 0 ? (
            <Text fontSize="sm">{filteredVulnerabilities[0].description || 'No description available.'}</Text>
          ) : (
            <Text fontSize="sm" color="gray.500">Select a vulnerability to view details.</Text>
          )}
        </Box>
      </Box>

      {/* Page info */}
      {filteredVulnerabilities.length > 0 && (
        <Text fontSize="xs" color="gray.500" textAlign="center" mt={1}>
          Showing {indexOfFirstItem + 1}-{Math.min(indexOfLastItem, filteredVulnerabilities.length)} of {filteredVulnerabilities.length} vulnerabilities
          {isDateFilterActive && ` (date filtered)`}
        </Text>
      )}
    </Box>
  );
};

export default VulnerabilityPanel;
